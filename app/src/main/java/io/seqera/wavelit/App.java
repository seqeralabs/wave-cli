/*
 *  Copyright (c) 2023, Seqera Labs.
 *
 *  This Source Code Form is subject to the terms of the Mozilla Public
 *  License, v. 2.0. If a copy of the MPL was not distributed with this
 *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 *  This Source Code Form is "Incompatible With Secondary Licenses", as
 *  defined by the Mozilla Public License, v. 2.0.
 */

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.seqera.wavelit;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.stream.Collectors;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import io.seqera.wave.api.BuildContext;
import io.seqera.wave.api.ContainerConfig;
import io.seqera.wave.api.ContainerLayer;
import io.seqera.wave.api.SubmitContainerTokenRequest;
import io.seqera.wave.api.SubmitContainerTokenResponse;
import io.seqera.wave.config.CondaOpts;
import io.seqera.wave.config.SpackOpts;
import io.seqera.wave.util.DockerHelper;
import io.seqera.wave.util.Packer;
import io.seqera.wavelit.exception.IllegalCliArgumentException;
import io.seqera.wavelit.json.JsonHelper;
import io.seqera.wavelit.util.BuildInfo;
import io.seqera.wavelit.util.CliVersionProvider;
import io.seqera.wavelit.util.YamlHelper;
import org.slf4j.LoggerFactory;
import picocli.CommandLine;
import static io.seqera.wave.util.DockerHelper.addPackagesToSpackFile;
import static io.seqera.wave.util.DockerHelper.spackPackagesToSpackFile;
import static org.apache.commons.lang3.StringUtils.isEmpty;
import static picocli.CommandLine.Command;
import static picocli.CommandLine.Option;

/**
 * Wavelit main class
 */
@Command(name = "wavelit", description = "Wave command line tool", mixinStandardHelpOptions = true, versionProvider = CliVersionProvider.class, usageHelpAutoWidth = true)
public class App implements Runnable {

    private static final String DEFAULT_TOWER_ENDPOINT = "https://api.tower.nf";

    private static final long _1MB = 1024 * 1024;

    @Option(names = {"-i", "--image"}, paramLabel = "''", description = "Container image name to be provisioned e.g alpine:latest.")
    private String image;

    @Option(names = {"-f", "--containerfile"}, paramLabel = "''", description = "Container file to be used to build the image e.g. ./Dockerfile.")
    private String containerFile;

    @Option(names = {"--tower-token"}, paramLabel = "''", description = "Tower service access token.")
    private String towerToken;

    @Option(names = {"--tower-endpoint"}, paramLabel = "''", description = "Tower service endpoint e.g. https://api.tower.nf.")
    private String towerEndpoint;

    @Option(names = {"--tower-workspace-id"}, paramLabel = "''", description = "Tower service workspace ID e.g. 1234567890.")
    private Long towerWorkspaceId;

    @Option(names = {"--build-repo"}, paramLabel = "''", description = "The container repository where image build by Wave will stored e.g. docker.io/user/build.")
    private String buildRepository;

    @Option(names = {"--cache-repo"}, paramLabel = "''", description = "The container repository where image layer created by Wave will stored e.g. docker.io/user/cache.")
    private String cacheRepository;

    @Option(names = {"--wave-endpoint"}, paramLabel = "''", description = "Wave service endpoint e.g. https://wave.seqera.io.")
    private String waveEndpoint;

    @Option(names = {"--freeze"}, paramLabel = "false",  description = "Request a container freeze.")
    private boolean freeze;

    @Option(names = {"--platform"}, paramLabel = "''", description = "Platform to be used for the container build. One of: linux/amd64, linux/arm64.")
    private String platform;

    @Option(names = {"--await"}, paramLabel = "false",  description = "Await the container build to be available.")
    private boolean await;

    @Option(names = {"--context"}, paramLabel = "''",  description = "Directory path where the build context is stored e.g. /some/context/path.")
    private String contextDir;

    @Option(names = {"--layer"}, paramLabel = "''", description = "Directory path where a layer content is stored e.g. /some/layer/path")
    private List<String> layerDirs;

    @Option(names = {"--config-cmd"}, paramLabel = "''", description = "Overwrite the default CMD (command) of the image.")
    private String command;

    @Option(names = {"--config-entrypoint"}, paramLabel = "''", description = "Overwrite the default ENTRYPOINT of the image.")
    private String entrypoint;

    @Option(names = {"--config-working-dir"}, paramLabel = "''", description = "Overwrite the default WORKDIR of the image e.g. /some/work/dir.")
    private String workingDir;

    @Option(names = {"--conda-file"}, paramLabel = "''", description = "A Conda file used to build the container e.g. /some/path/conda.yaml.")
    private String condaFile;

    @Option(names = {"--conda-package"}, paramLabel = "''", description = "One or more Conda package used to build the container e.g. bioconda::samtools=1.17.")
    private List<String> condaPackages;

    @Option(names = {"--conda-base-image"}, paramLabel = "''", description = "Conda base image used to to build the container (default: ${DEFAULT-VALUE}).")
    private String condaBaseImage = CondaOpts.DEFAULT_MAMBA_IMAGE;

    @Option(names = {"--conda-run-command"}, paramLabel = "''", description = "Dockerfile RUN commands used to build the container.")
    private List<String> condaRunCommands;

    @Option(names = {"--conda-channels"}, paramLabel = "''", description = "Conda channels used to build the container (default: ${DEFAULT-VALUE}).")
    private String condaChannels = "seqera,bioconda,conda-forge,defaults";

    @Option(names = {"--spack-file"}, paramLabel = "''",  description = "A Spack file used to build the container e.g. /some/path/spack.yaml.")
    private String spackFile;

    @Option(names = {"--spack-package"}, paramLabel = "''", description = "One or more Spakc package used to build the container e.g. cowsay.")
    private List<String> spackPackages;

    @Option(names = {"--spack-run-command"}, paramLabel = "''",  description = "Dockerfile RUN commands used to build the container.")
    private List<String> spackRunCommands;

    @Option(names = {"--log-level"}, paramLabel = "''", description = "Set the application log level. One of: OFF, ERROR, WARN, INFO, DEBUG, TRACE and ALL")
    private String logLevel;

    @Option(names = {"-o","--output"}, paramLabel = "json|yaml",  description = "Output format. One of: json, yaml.")
    private String outputFormat;

    private BuildContext buildContext;

    private ContainerConfig containerConfig;

    public static void main(String[] args) {
        try {
            final App app = new App();
            final CommandLine cli = new CommandLine(app);
            final CommandLine.ParseResult result = cli.parseArgs(args);
            if( result.matchedArgs().size()==0 || result.isUsageHelpRequested() ) {
                cli.usage(System.out);
            }
            else if( result.isVersionHelpRequested() ) {
                System.out.println(BuildInfo.getFullVersion());
            }
            else {
                app.run();
            }
        }
        catch (IllegalCliArgumentException e) {
            System.err.println(e.getMessage());
            System.exit(1);
        }
        catch (Throwable e) {
            e.printStackTrace(System.err);
            System.exit(1);
        }
    }

    protected void setLogLevel() {
        if( !isEmpty(logLevel) ) {
            Logger root = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
            root.setLevel(Level.valueOf(logLevel));
        }
    }

    protected void defaultArgs() {
        if( "null".equals(towerEndpoint) )  {
            towerEndpoint = null;
        }
        else if( isEmpty(towerEndpoint) && System.getenv().containsKey("TOWER_API_ENDPOINT") ) {
            towerEndpoint = System.getenv("TOWER_API_ENDPOINT");
        }
        else if( isEmpty(towerEndpoint) ) {
            towerEndpoint = DEFAULT_TOWER_ENDPOINT;
        }

        if( "null".equals(towerToken) ) {
            towerToken = null;
        }
        else if( isEmpty(towerToken) && System.getenv().containsKey("TOWER_ACCESS_TOKEN") ) {
            towerToken = System.getenv("TOWER_ACCESS_TOKEN");
        }
        if( towerWorkspaceId==null && System.getenv().containsKey("TOWER_WORKSPACE_ID") ) {
            towerWorkspaceId = Long.valueOf(System.getenv("TOWER_WORKSPACE_ID"));
        }

        if( isEmpty(waveEndpoint) && System.getenv().containsKey("WAVE_ENDPOINT") ) {
            waveEndpoint = System.getenv("WAVE_ENDPOINT");
        }
        else if( isEmpty(waveEndpoint) ) {
            waveEndpoint = Client.DEFAULT_ENDPOINT;
        }

    }

    protected void validateArgs() {
        if( !isEmpty(image) && !isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Argument --image and --containerfile conflict each other - Specify an image name or a container file for the container to be provisioned");

        if( isEmpty(image) && isEmpty(containerFile) && isEmpty(condaFile) && condaPackages==null  && isEmpty(spackFile) && spackPackages ==null  )
            throw new IllegalCliArgumentException("Provide either a image name or a container file for the Wave container to be provisioned");

        if( freeze && isEmpty(buildRepository) )
            throw new IllegalCliArgumentException("Specify the build repository where the freeze container will be pushed by using the --build-repo option");

        if( isEmpty(towerToken) && !isEmpty(buildRepository) )
            throw new IllegalCliArgumentException("Specify the Tower access token required to authenticate the access to the build repository either by using the --tower-token option or the TOWER_ACCESS_TOKEN environment variable");

        // -- check conda options
        if( !isEmpty(condaFile) && condaPackages!=null )
            throw new IllegalCliArgumentException("Option --conda-file and --conda-package conflict each other");

        if( !isEmpty(condaFile) && !isEmpty(image) )
            throw new IllegalCliArgumentException("Option --conda-file and --image conflict each other");

        if( !isEmpty(condaFile) && !isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Option --conda-file and --containerfile conflict each other");

        if( condaPackages!=null && !isEmpty(image) )
            throw new IllegalCliArgumentException("Option --conda-package and --image conflict each other");

        if( condaPackages!=null && !isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Option --conda-package and --containerfile conflict each other");

        // -- check spack options
        if( !isEmpty(spackFile) && spackPackages!=null )
            throw new IllegalCliArgumentException("Option --spack-file and --spack-package conflict each other");

        if( !isEmpty(spackFile) && !isEmpty(image) )
            throw new IllegalCliArgumentException("Option --spack-file and --image conflict each other");

        if( !isEmpty(spackFile) && !isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Option --spack-file and --containerfile conflict each other");

        if( spackPackages!=null && !isEmpty(image) )
            throw new IllegalCliArgumentException("Option --spack-package and --image conflict each other");

        if( spackPackages!=null && !isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Option --spack-package and --containerfile conflict each other");

        if( !isEmpty(outputFormat) && !List.of("json","yaml").contains(outputFormat) ) {
            final String msg = String.format("Invalid output format: '%s' - expected value: json, yaml", outputFormat);
            throw new IllegalCliArgumentException(msg);
        }

        if( condaPackages!=null && spackPackages!=null )
            throw new IllegalCliArgumentException("Option --conda-package and --spack-package conflict each other");

        if( condaPackages!=null && !isEmpty(spackFile) )
            throw new IllegalCliArgumentException("Option --conda-package and --spack-file conflict each other");

        if( !isEmpty(condaFile) && spackPackages!=null )
            throw new IllegalCliArgumentException("Option --conda-file and --spack-package conflict each other");

        if( !isEmpty(condaFile) && !isEmpty(spackFile) )
            throw new IllegalCliArgumentException("Option --conda-file and --spack-file conflict each other");

        if( !isEmpty(contextDir) && isEmpty(containerFile) )
            throw new IllegalCliArgumentException("Option --context requires the use of a container file");

        if( !isEmpty(contextDir) ) {
            // check that a container file has been provided
            if( isEmpty(containerFile) )
                throw new IllegalCliArgumentException("Container context directory is only allowed when a build container file is provided");
            Path location = Path.of(contextDir);
            // check it exist
            if( !Files.exists(location) )
                throw new IllegalCliArgumentException("Context path does not exists - offending value: " + contextDir);
            // check it's a directory
            if( !Files.isDirectory(location) )
                throw new IllegalCliArgumentException("Context path is not a directory - offending value: " + contextDir);
        }
    }

    protected Client client() {
        return new Client().withEndpoint(waveEndpoint);
    }

    protected SubmitContainerTokenRequest createRequest() {
        return new SubmitContainerTokenRequest()
                .withContainerImage(image)
                .withContainerFile(containerFileBase64())
                .withCondaFile(condaFileBase64())
                .withSpackFile(spackFileBase64())
                .withContainerPlatform(platform)
                .withTimestamp(OffsetDateTime.now())
                .withBuildRepository(buildRepository)
                .withCacheRepository(cacheRepository)
                .withBuildContext(buildContext)
                .withContainerConfig(containerConfig)
                .withTowerAccessToken(towerToken)
                .withTowerWorkspaceId(towerWorkspaceId)
                .withTowerEndpoint(towerEndpoint)
                .withFreezeMode(freeze);
    }

    @Override
    public void run() {
        setLogLevel();
        // default Args
        defaultArgs();
        // validate the command line args
        validateArgs();
        // prepare the request
        buildContext = prepareContext();
        containerConfig = prepareConfig();
        // create the wave request
        SubmitContainerTokenRequest request = createRequest();
        // creat the client
        final Client client = client();
        // submit it
        SubmitContainerTokenResponse resp = client.submit(request);
        // await build to be completed
        if( await && !isEmpty(resp.buildId) )
            client.awaitImage(resp.targetImage);
        // print the wave container name
        System.out.println(dumpOutput(resp));
    }

    private String encodePathBase64(String value) {
        try {
            if( isEmpty(value) )
                return null;
            // read the text from a URI resource and encode to base64
            if( value.startsWith("file:/") || value.startsWith("http://") || value.startsWith("https://")) {
                return Base64.getEncoder().encodeToString(Files.readAllBytes(Path.of(new URI(value))));
            }
            // read the text from a local file and encode to base64
            return Base64.getEncoder().encodeToString(Files.readAllBytes(Path.of(value)));
        }
        catch (URISyntaxException e) {
            throw new IllegalCliArgumentException("Invalid container file URI path - offending value: " + value, e);
        }
        catch (NoSuchFileException | FileNotFoundException e) {
            throw new IllegalCliArgumentException("File not found: " + value, e);
        }
        catch (IOException e) {
            String msg = String.format("Unable to read resource: %s - reason: %s" + value, e.getMessage());
            throw new IllegalCliArgumentException(msg, e);
        }
    }

    private String encodeStringBase64(String value) {
        if( isEmpty(value) )
            return null;
        else
            return Base64.getEncoder().encodeToString(value.getBytes());
    }

    protected BuildContext prepareContext()  {
        if( isEmpty(contextDir) )
            return null;
        BuildContext result = null;
        try {
            result = BuildContext.of(new Packer().layer(Path.of(contextDir)));
        }
        catch (IOException e) {
            throw new RuntimeException("Unexpected error while preparing build context - cause: "+e.getMessage(), e);
        }
        if( result.gzipSize > 5*_1MB )
            throw new RuntimeException("Build context cannot be bigger of 5 MiB");
        return result;
    }

    protected ContainerConfig prepareConfig() {
        final ContainerConfig result = new ContainerConfig();

        // add the entrypoint if specified
        if( entrypoint!=null )
            result.entrypoint = List.of(entrypoint);

        // add the command if specified
        if( command != null ){
            if( "".equals(command.trim()) ) throw new IllegalCliArgumentException("The command cannot be an empty string");
            result.cmd = List.of(command);
        }

        //add the working directory if specified
        if( workingDir != null ){
            if( "".equals(workingDir.trim()) ) throw new IllegalCliArgumentException("The working directory cannot be empty string");
            result.workingDir = workingDir;
        }

        // add the layers to the resulting config if specified
        if( layerDirs!=null ) for( String it : layerDirs ) {
            final Path loc = Path.of(it);
            if( !Files.isDirectory(loc) ) throw new IllegalCliArgumentException("Not a valid container layer directory - offering path: "+loc);
            ContainerLayer layer;
            try {
                result.layers.add( layer=new Packer().layer(loc) );
            }
            catch (IOException e ) {
                throw new RuntimeException("Unexpected error while packing container layer at path: " + loc, e);
            }
            if( layer.gzipSize > _1MB )
                throw new RuntimeException("Container layer cannot be bigger of 1 MiB - offending path: " + loc);
        }
        // check all size
        long size = 0;
        for(ContainerLayer it : result.layers ) {
            size += it.gzipSize;
        }
        if( size>=10 * _1MB )
            throw new RuntimeException("Compressed container layers cannot exceed 10 MiB");

        // return the result
        return !result.empty() ? result : null;
    }

    protected String containerFileBase64() {
        if( !isEmpty(containerFile) ) {
            return encodePathBase64(containerFile);
        }

        if( !isEmpty(condaFile) || condaPackages!=null ) {
            final CondaOpts opts = new CondaOpts()
                    .withMambaImage(condaBaseImage)
                    .withCommands(condaRunCommands);
            final String result = condaPackages!=null
                    ? DockerHelper.condaPackagesToDockerFile(condaPackages.stream().collect(Collectors.joining(" ")), Arrays.asList(condaChannels.split(",")), opts)
                    : DockerHelper.condaFileToDockerFile(opts);
            return encodeStringBase64(result);
        }

        if( !isEmpty(spackFile) || spackPackages!=null ) {
            final SpackOpts opts = new SpackOpts() .withCommands(spackRunCommands);
            final String result = DockerHelper.spackFileToDockerFile(opts);
            return encodeStringBase64(result);
        }

        return null;
    }

    protected String condaFileBase64() {
        if( isEmpty(condaFile) )
            return null;
        return encodePathBase64(condaFile);
    }

    protected String spackFileBase64() {
        if( !isEmpty(spackFile) ) {
            // parse the attribute as a spack file path *and* append the base packages if any
            return encodePathBase64(addPackagesToSpackFile(spackFile, new SpackOpts()).toString());
        }
        else if( spackPackages!=null && spackPackages.size()>0  ) {
            // create a minimal spack file with package spec from user input
            final String packages = spackPackages.stream().collect(Collectors.joining(" "));
            return encodePathBase64(spackPackagesToSpackFile(packages, new SpackOpts()).toString());
        }
        else
            return null;
    }

    protected String dumpOutput(SubmitContainerTokenResponse resp) {
        if( "yaml".equals(outputFormat) ) {
            return YamlHelper.toYaml(resp);
        }
        if( "json".equals(outputFormat) ) {
            return JsonHelper.toJson(resp);
        }
        if( outputFormat!=null )
            throw new IllegalArgumentException("Unexpected output format: "+outputFormat);

        return freeze
                ? resp.containerImage
                : resp.targetImage;
    }
}
